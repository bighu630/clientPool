# 代码生成工具快速入门

## 简介

clientPool 代码生成工具可以自动为你的接口或结构体生成带连接池管理和监控的包装代码，无需手动编写重复的样板代码。

## 使用场景

假设你有一个 RPC 客户端接口，需要：
1. 使用连接池管理多个客户端实例
2. 自动负载均衡
3. Prometheus 监控每个方法的调用情况
4. 熔断器保护

传统方式需要为每个方法手动编写包装代码，非常繁琐。使用代码生成工具，一条命令即可完成。

## 三步完成

### 1. 定义你的接口

```go
// rpc/client.go
package rpc

import "context"

type Client interface {
    GetSlot(ctx context.Context, commitment string) (uint64, error)
    GetBlockHeight(ctx context.Context, commitment string) (uint64, error)
    SendTransaction(ctx context.Context, tx []byte) (string, error)
}
```

### 2. 生成包装代码

```bash
codegen \
  -package=github.com/yourproject/rpc \
  -type=Client \
  -wrapper=MultiRPCClient \
  -client=rpc.Client \
  -output=./rpc/multi_client_generated.go
```

生成的代码：

```go
// Code generated by clientPool codegen. DO NOT EDIT.

package rpc

import (
    "context"
    "github.com/bighu630/clientPool/middleware"
)

// GetSlot wraps the client method with pool management and monitoring
func (m *MultiRPCClient) GetSlot(ctx context.Context, commitment string) (ret0 uint64, err error) {
    ctx = context.WithValue(ctx, middleware.PrometheusMethodKey{}, "get_slot")
    err = m.pool.Do(ctx, func(ctx context.Context, client rpc.Client) error {
        ret0, err = client.GetSlot(ctx, commitment)
        return err
    })
    return
}

// ... 其他方法
```

### 3. 创建包装器结构体并使用

```go
// rpc/multi_client.go
package rpc

import (
    clientpool "github.com/bighu630/clientPool"
    "github.com/bighu630/clientPool/middleware"
    "time"
)

// MultiRPCClient 多客户端包装器
type MultiRPCClient struct {
    pool *clientpool.ClientPool[Client]
}

// NewMultiRPCClient 创建新的多客户端包装器
func NewMultiRPCClient(endpoints []string) *MultiRPCClient {
    // 创建客户端池
    pool := clientpool.NewClientPool[Client](
        3,                        // 最大失败次数
        5*time.Second,           // 熔断器冷却时间
        clientpool.RoundRobin,   // 负载均衡策略
    )
    
    // 注册中间件
    pool.RegisterMiddleware(middleware.PrometheusMiddleware[Client]())
    pool.RegisterMiddleware(middleware.NewRateLimiterMiddleware[Client](100, 200, 2*time.Second))
    
    // 添加客户端
    for i, endpoint := range endpoints {
        client := NewRPCClient(endpoint) // 你的客户端实现
        pool.AddClient(client, i+1)
    }
    
    return &MultiRPCClient{
        pool: pool,
    }
}

// 使用
func main() {
    // 创建多客户端（自动负载均衡）
    multiClient := NewMultiRPCClient([]string{
        "https://api1.example.com",
        "https://api2.example.com",
        "https://api3.example.com",
    })
    
    // 直接调用方法，自动使用连接池和监控
    slot, err := multiClient.GetSlot(context.Background(), "finalized")
    if err != nil {
        panic(err)
    }
    
    fmt.Printf("Current slot: %d\n", slot)
}
```

## 高级功能

### 自定义池字段名

如果你的结构体有多个池，可以自定义字段名：

```bash
codegen \
  -package=github.com/yourproject/rpc \
  -type=Client \
  -wrapper=MultiRPCClient \
  -client=rpc.Client \
  -pool=scannerPool \
  -output=./rpc/scanner_client_generated.go
```

### 禁用 Prometheus 监控

```bash
codegen \
  -package=github.com/yourproject/rpc \
  -type=Client \
  -wrapper=MultiRPCClient \
  -client=rpc.Client \
  -prometheus=false \
  -output=./rpc/multi_client_generated.go
```

### 支持结构体（不仅仅是接口）

代码生成工具也支持为结构体生成包装代码：

```go
type RPCClient struct {
    endpoint string
}

func (c *RPCClient) GetSlot(ctx context.Context) (uint64, error) {
    // ...
}
```

```bash
codegen \
  -package=github.com/yourproject/rpc \
  -type=RPCClient \
  -wrapper=MultiRPCClient \
  -client=*rpc.RPCClient \
  -output=./rpc/multi_client_generated.go
```

## Prometheus 监控

生成的代码会自动在每个方法调用时注入方法名到 context，配合 PrometheusMiddleware 可以实现细粒度的监控：

```
# 按客户端和方法统计请求数
middleware_requests_total{client="client1",method="get_slot"} 100
middleware_requests_total{client="client1",method="get_block_height"} 50

# 按客户端和方法统计耗时
middleware_request_duration_seconds{client="client1",method="get_slot"} 0.05

# 按客户端和方法统计错误
middleware_request_errors_total{client="client1",method="get_slot"} 2
```

## 完整示例

查看 [examples/codegen](../examples/codegen) 目录获取完整的可运行示例。

## 常见问题

**Q: 生成的代码可以手动修改吗？**  
A: 不建议修改生成的代码，因为再次运行生成命令会覆盖修改。如需自定义，建议在包装器结构体中添加额外的方法。

**Q: 如何处理私有方法？**  
A: 代码生成工具只会生成公有方法（首字母大写），私有方法不会被包装。

**Q: 支持泛型方法吗？**  
A: 目前不支持泛型方法，但支持泛型类型作为参数或返回值。

**Q: 如何处理复杂的返回值类型？**  
A: 代码生成工具会自动识别所有参数和返回值类型，包括指针、切片、Map等复杂类型。

## 相关文档

- [完整文档](README.md)
- [示例代码](../examples/codegen)
- [主项目 README](../README.md)
